---
category: blog
title: Why is functional programming awesome. A primer.
layout: blog
---

I really am not the best person to author such an article (I am not that into programming anymore, and I never was a real expert in it), however I am doing it, because I have been waiting for someone else to write it for years and kept noticing the following phenomena:

1. People who understand functional programming, cannot make themselves understood by the general (programming) public.
2. People who are able to make themselves understood by the public, don't understand enough for them to be worth listening (all functional programming articles that are understanable don't go much farther than "You should use pure functions, man!".

Roughly the same thing has been called  "the curse of the monad" by some people: "Once you understand it, you lose the ability to explain it".

It is clear now that monads are not something you get in an afternoon, but I think you can get some idea of what FP (functional programming) is in an afternoon. Or, you know, an year or so. But in order to spend that thime you need some motivation. You probably need someone to tell you why exactly do you need to know about FP. Why is it awesome, so to say. And so my article begins. 

Before starting, keep in mind that you need a clear mind to understand FP. So for a second forget everything that you know about programming paradigms. Forget the Object Oriented religious bullshit, that you learned at school, or by reading different versions of the same blog post - noone really can or does program like that. Forget the old timers, who think that if they don't have all the power at their fingertips at all times they are not as productive as they can be - they had 50 years to write a program that does not crash and they failed. And lastly, forget the all the Haskell enthusiasts, if you have ever encountered this specie - they are on the hunt for the best programming architecture, which is admirable, but I prefer to have an OK architecture that is vaguely understood by, say 50 percent of all developers, than to have a perfect architecture, understood by 0.001 percent.

Pure functions
===

Of course we begin our journey with _pure_ functions. I'd know that FP has won when I see an article about it, which does not start with "What are pure functions?". But this explanation is still needed, I think. For practical reasons you can think of a pure function in any programming language as one which:

1. In its body, it does *not* modify (mutate) the values of the arguments it accepts.
2. It also does not mutate, or change, the values of any external variables which it may access (although it *may* access external variables, provided that their values don't change).
3. In its body, it only calls other pure functions.

Again, this is a _practical_ definition, and for this reason it may be quite different from the ones that you may have heard (which are often based on theory). For example you may have heard that a pure function is one which is "referentially transparent" which is a fancy way of saying that it returns the same output given the same input - this is a good definition, but it is incomplete: the `console.log` function in JS returns the same output for every input - `undefined`. That does not make it a pure function. Plus is the definition is not enough for someone who does not already know a thing or two it may leave you asking, "OK, but how do I make a function referentially transparent?". The answer to this the list above.

You may have heard that pure functions are ones that don't perform assignment. This is a nice definition, but it is a little bit sloppy. Does `console.log` perform any assigment - this is debatable. But does `console.log` modify some external variable somewhere? Well, we can be sure that the state of our console is stored in some variable somewhere and we can also be sure that this state is changed from calling the function, so for all practical reasons it does. In fact, this is the reason we are using `console.log` in the first place - we want the "side effect" - printing something on screen (as opposed to calling it for the value it produces). 


This leads us to maybe the best (and most confusing) definition of pure functions - they are the ones which have no _observable side effects_. In other words, it woudn't make any difference for our users if we call these function 10 or 100 times. It won't make any difference to them if we called the function now, or we used some cached result from calling it 10 days ago with the same arguments. The key to this definition's correctness is that it is a _subjective_ one, not an objective one. And that settles some questions like: 

> Wait a minute, after all, all our functions write and delete some values in the registers of the CPU, so aren't all of them are really impure? And what is this "outside world" anyways? Isn't this all virtual?

Yes it is so in order to rigorously define pure functions we first define the events which are observable by our users (such as a sound coming from the speakers, the image on the screen, the time they spend waiting for a given resource to be fetched etc.) and we study the functions which don't touch those. To some people side-effect-free would mean a different thing than to others. For example you may say that logging in some file is not a side effect, simply because your users won't ever open it and you won't run out of space, so logging "doesn't count". This is OK, you will have parts of your program which will do all kinds of side effects anyways. But let's not get ahead of ourselves.

Equational Reasoning 
===

So is that distinction, the one between pure and impure functions, so important? The answer is simple: because pure functions are data. If you are interested in Lisp, you may have heard that all code is data, but for pure functions, this slogan is valid in a slightly different way: Every pure function can be represented by, and is _isomorphic_ to, a dictionary data structure, with the function's inputs as keys, and its outputs as values. In mathematics, it is called a _function table_. I will give you an example with the function which converts an integer to a string:

```
const stringifyFn = (number) => String(number)
```

There are a finite number of integers, so it is entirely possible, and for some occasions even practical, to define such a function as a datastructire:


```
const stringifyTable = new Map([
  [1, '1'],
  [2, '2'],
  [3, '3'],
  [4, '4']
  ...
])
```
And behold: 

```
stringifyFn(1) === stringifyTable.get(1) //true
```

This is probably the most important example you will see if you want to understand what is FP all about. Not all functions can _really_
 be represented as data structures (many of them have infinite inputs), but all of them can be reasoned about as such. One way to grasp the power of this concept is to imagine how the function-data isomorphism scales. Imagine a simple function like the one you see above being used in a more complex but also pure function. Which is being used by a yet another one... You might arrive to some very complex piece of functionality, but as long as you follow the three principles of purity which were stated above, what you created is an equivalent to, and can be used as, a simple datastructure, which contains keys and corresponding values. Can there be a bug in a datastructure? Well, a datastructure can be incorrect yes, but as long as it has outputs for all inputs, it will always work. 
 
Let me reiterate that all this is valid only as long as you follow strictly the principles which I stated above, particularily the third one: that a function should only call other pure functions. When experts say that "mostly functional programming" does not work they mean exactly this - that you cannot build a program that is, you know, almost purely-functional, but it uses just a couple of side effects and get (almost) the same benefits as you would by a truly purely-functional program. This is because the reasoning model of FP and imperative programming is different.

What about functions that take more than one parameter, like `(a, b) => a + b`. Well, you can think of them either as functions which take a compostite parameter(`(ab) => ab[0] + ab[1]`), or as functions who return other functions(`(a) => (b) => a + b`).

What about objects? Well, immutable objects are not excluded in any way from the party. If you have an object `x` with methods `a` and `b`, you can think of it either as a function `x` which takes one string which can be either `a` and `b` as a parameter (the name of the "message"), and one datastructure, containing the arguments. You can also think of it as a data structure `x`, with two functions (`a` and `b`) that just happen to have access to `x`. Using this approach, Even the most complex function constitutes nothing more, than a series of simple functions, and even the biggest taxonomy can be reduced to an ordinary datastructure from which you can just take the result, or results, that you need.

We can even identify different paths in our system which lead to the same result for the purpose of optimization, or just in order to reach better understanding of our program.

Functional Runtimes
===

You can find a lot of information about how nice it is to have referential transparency and to be able to apply equational reasoning. You won't, however, have much success in finding information about what to do next. That is the topic of this chapter: how the hell creating a bunch of pure functions would help me create a GUI application, for example? Or a concurrent web server? Many functional programming tutorials seem to dismiss this question as uninteresting, but for me it is essential: running side effects is a tough job, but someone has to do it. Enter the exciting, and not very well-researched topic of functional runtimes, AKA programs that bind (no pun intended) purely-functional programs to the real world. So what is the big idea? Simple: you design your program, you split it to two parts - one is the purely functional part which, if you are good, will be the better and bigger part of your program and the other will be the imperative part, which should be as simple as possible and also as generic as possible, so many different programs can use it. Don't take the term "runtime" literally here. In some contexts, this "runtime" can be just a simple library for running purely-functional programs that solve a specific set of problems. But the runtime can also be very complex, and support many options. 

The closest thing we have to a functional runtime in the traditional programming world are the domain-specific languages. Think of CSS, for example - CSS is a purely functional language that allow you to define the layout of a webpage easily and bug free. Its secret is that CSS code itself does not do anything. Most of the hard job is done by its runtime (the browser) - a runtime that is not very simple, but is very versatile and can support a whole class of programs (in this case graphical user interfaces).

CSS is, of course, not a very powerful language. Which is unfortunate: imagine having the ability to embedd some real (purely-functional) code in CSS class definition, that decides how the elements from this class be positioned, based on the position of other elements, and on other forms of state. This would allow us to be a lot more flexible when creating a dynamic layout, and still don't worry about the layout blowing in our face, bringing us many of the benefits of having access to a powerful tool, without any of the drawbacks. The whole philosophy actually boils down to that old principle about separating your code from your data. If you consider pure functions data, that is. If you don't, the practice of separating your code from your data would still be usefull, albeit very limited - anytime you need a more complex structure you will either have to copy and paste like crazy or just to drop the whole practice altogether.

Now back to functional runtimes: as I said creating one involves splitting your program to two parts:

1. A pure function (or an immutable object containing pure just functions) which should encompass as much of your functionality as possible.
2. A bunch of imperative code supportting the pure part, which should be as small and as generic as possible.

Making this split is, for me at least, the heart of the matter over how to do FP. Generally there is no magic formula for doing it. It is different for different kinds of programs. Let me reiterate that it is crucial that you do not cheat Keep a clean distinction between the two parts - keep them in separate folders, separate files, use a linter which limits the use of non-pure language features like assignments, mutability, accessing global variables. And never say stuff like:

> I'll just insert this *small* mutable state here, and nobody will notice.

or:

> ...but otherwise I have to rework ALL of my program!

You will have much more benefit from a small purely-functional module than if most of your program is mostly-functional but not quite there yet.

Some classes of programs can be very trivially split into a purely-functional and an imperative part - think of command line tools for example, especially those of them which only use `STDIN` and `STDOUT`, like the `grep` tool. Such tools have a very simple runtime - one which just takes the input, feeds it to the purely-functional part and when it finishes, it passes the return value to `STDOUT` - you can say that they are pure functions in disguise. 


So let's see how would we implement a small version of `grep` in node.js. We will start with the purely functional part (called `grep-pure.js`) because it is the easiest:

```javascript
module.exports = (input, args) => 
    input.split('\n')
        .filter((row) => row.includes(args.pattern))
        .join('\n')
```

Not much to see here. We just splitt the string to a list, and then we do our work using the well-know list operators. All these methods are analogous to pure functions, because ther don't modify the object to which they are called. Instead what they do is to return a different object which serves as new "version" of the same object - a popular trick in FP. 

The function that we define is also a pure one, because it does not modify the values of its arguments: `input` and `args`, does not access any external variables, like `process` for example. We access the external variable `pattern` in the anonymous function that we pass to `filter`. This is OK, provided that we don't modify it (we don't) and that the variable is immutable. This explanation made the whole thing sound more complicated than it is - I just wrote the function using only immutable data and whenever I needed something I defined it as an argument.

OK, now let's get to the more interesting part - the `grep-runtime.js`. Because we want to be as versatile as possible, we will define a generic runtime for writing CLI applications. It is easier than it looks:

```javascript
module.exports = (f) => {
    const args = require('minimist')(process.argv.slice(2))
    require('get-stdin')().then((input) => {
        console.log(f(input, Object.freeze(args)))
    })
}
```

Here we are using effectful functions like crazy. That is how it should be - all pure functions should be moved outside of this file. We use `Object.freeze` to enforce the principle that we discussed earlier - a pure function should not mutate its arguments.

We wrote a pure grep implementation as a pure function and a generic function for "lifting" pure functions into command-line tools. Our final program `grep.js` is what we get if we combine those two things together:

```javascript
#!/usr/bin/env node
require('./grep-runtime')(require('./grep-pure'))

```
The result is can be used like ordinary `grep` - you pipe a text stream through the tool, specify the pattern and you get the results:

```
/> cat file.txt | ./grep.js --pattern dog
< I like dogs.
< An there I saw a big fat dog.

```





You can view the distinction between pure and impure functions that we may make as the distinction between syncronous and asyncronous functions in platforms with non-blocking IO such as node.js. Non-blocking IO brings some very nice improvements in performance, but besides that it also brings a new mental model of the way we do programmings. At its core is the idea that functions which do network IO are special, and they should be threated differently than the ones that don't. If you think about it, in node.js, synchronous functions are those which: 

1. Do not perform any asynchronous operations.
2. Only call other synchronous functions.

So, the non-blocking paradigm resembles purely-functional programming, only it enforces purity takes care for just one type of side effect - network IO operations.




In low-level programming, _an assigment_ is the process of placing a value (like object, string etc.) in a specific memory location.

In mathematics, _a binding_ of a variable means associating it with another value, or an expression. 


The two concepts are obviously related, as the assignment was meant to work like a binding. That is why they are both denoted with the `=` sign. But there are some differences at how they typically function.

The big difference is that assignment includes places a big focus over how and when the value is computed. For example we know that the right-hand side of the expression is computed before the left one. This is what enables us to make utterly unmathematical things like `x = x + 1`, but also 
