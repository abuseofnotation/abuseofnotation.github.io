---
category: blog
title: Why is functional programming awesome. A primer.
layout: blog
---

I really am not the best person to be the author such an article - I am not that into programming anymore, and I never was a real expert in it. However I am doing it, because I have been waiting for someone else to write it for years and kept noticing the following phenomena:

1. People who understand functional programming, cannot make themselves understood by the general (programming) public.
2. People who are able to make themselves understood by the public, don't understand enough for them to be worth listening. 

Roughly the same thing has been called  "the curse of the monad" by some people: "Once you understand it, you lose the ability to explain it".

It is clear now that monads are not something you get in an afternoon, but I think you can get some idea of what FP (functional programming) is in an afternoon. Or, you know, an year or so. But in order to spend that thime you need some motivation. You probably need someone to tell you why exactly do you need to know about FP. Why is it awesome, so to say. And so my article begins. Before starting, keep in mind that you need a clear mind to understand it. So for a second forget everything that you know about programming paradigms. Forget the Object Oriented religious bullshit, that you learned at school, or by reading different versions of the same blog post - noone really can or does program like that. Forget the old timers, who think that if they don't have all the power at their fingertips at all times they are not as productive as they can be - they had 50 years to write a good big program that does not crash and they failed. And lastly, forget the all the Haskell enthusiasts, if you have ever encountered this specie - they are on the hunt for the best programming architecture, which is admirable, but I prefer to have an OK architecture that is vaguely understood by, say 50 percent of all developers, than to have a perfect architecture, understood by 0.001 percent.

Pure functions
===

Of course we begin our journey with _pure_ functions. I was joking that I'd know that FP has won when I see an article about it, which does not start with "What are pure functions?". But this explanation is still needed, I think. For practical reasons you can think of a pure function in any programming language as one which:

1. In its body, it does *not* modify (mutate) the values of the arguments it accepts.
2. It also does not mutate, or change, the values of any external variables which it may have access to.
3. In its body, it only calls other pure functions.

Again, this is a _practical_ definition, and for this reason it may be quite different from the ones that you may have heard (which are often based on theory). For example you may have heard that a pure function is one which is "referentially transparent" which is a fancy way of saying that it returns the same output given the same input - this is a good definition, but it is incomplete: the `console.log` function in JS returns the same output for every input - `undefined`. That does not make it a pure function. Plus is the definition is not enough for someone who does not already know a thing or two it may leave you asking, "OK, but how do I make a function referentially transparent?". The answer to this the list above.

You may have heard that pure functions are ones that don't perform assignment. This is a nice definition, but it is a little bit sloppy. Does `console.log` perform any assigment? I can't answer that. But does `console.log` modify some external variable somewhere? Well, we can be sure that the state of our console is stored in some variable somewhere and we can also be sure that this state is changed from calling the function, so for all practical reasons it does. In fact, this is the reason we are using `console.log` in the first place - for the "side effect" - printing something on screen (as opposed to calling it for the value it produces). 


This leads us to maybe the best (and most confusing) definition of pure functions - they are the ones which have no _observable side effects_. In other words, it woudn't make any difference for our users if we call these function 10 or 100 times. It won't make any difference to them if we called the function now, or we used some cached result from calling it 10 days ago with the same arguments. The key to this definition's correctness is that it is a _subjective_ one, not an objective one. And that settles some long-standing questions, like: 

> Wait a minute, after all, all our functions write and delete some values in the registers of the CPU, so aren't all of them are really impure? And what is this "outside world" anyways? Isn't this all virtual?

Yes it is - in order to define pure functions we first define the events which are observable by our users (such as a sound coming from the speakers, the image on the screen, the time they spend waiting for a given resource to be fetched etc.) and we study the functions which don't touch those. To some people side-effect-free would mean a different thing than to others. For example you may say that logging in some file is not a side effect, simply because your users won't ever open it and you won't run out of space, so logging "doesn't count". This is OK, you will have parts of your program which will do all kinds of side effects anyways. But let's not get ahead of ourselves.

Equational reasoning 
===

So why do we make that distinction between pure and impure functions? The answer is simple: because pure functions are data. If you are interested in Lisp, you may have heard that all code is data, but for pure functions, this slogan is valid in a different way: Every pure function can be represented by, and is isomorphic to, a dictionary data structure, with the function's inputs as keys, and its outputs as values. In mathematics, it is called a _function table_. I will give you an example with the function which converts an integer to a string:

```
const stringifyFn = (number) => String(number)
```

There are a finite number of integers, so it is entirely possible, and for some occasions even practical, to define such a function as a datastructire:


```
const stringifyTable = new Map([
  [1, '1'],
  [2, '2'],
  [3, '3'],
  [4, '4']
  ...
])
```
And behold: 

```
stringifyFn(1) === stringifyTable.get(1) //true
```

This will be the only example in this article, and is probably the most important example you will see if you want to understand what is FP all about. Of course not all functions can _really_
 be represented as data structures, but all of them can be reasoned about as such. Imagine how this scales. 







 
You can view the distinction between pure and impure functions that we may make as the distinction between syncronous and asyncronous functions in platforms with non-blocking IO such as node.js. Non-blocking IO brings some very nice improvements in performance, but besides that it also brings a new mental model of the way we do programmings. At its core is the idea that functions which do network IO are special, and they should be threated differently than the ones that don't. If you think about it, in node.js, synchronous functions are those which: 

1. Do not perform any asynchronous operations.
2. Only call other synchronous functions.

So, the non-blocking paradigm resembles purely-functional programming, only it enforces purity takes care for just one type of side effect - network IO operations.




In low-level programming, _an assigment_ is the process of placing a value (like object, string etc.) in a specific memory location.

In mathematics, _a binding_ of a variable means associating it with another value, or an expression. 


The two concepts are obviously related, as the assignment was meant to work like a binding. That is why they are both denoted with the `=` sign. But there are some differences at how they typically function.

The big difference is that assignment includes places a big focus over how and when the value is computed. For example we know that the right-hand side of the expression is computed before the left one. This is what enables us to make utterly unmathematical things like `x = x + 1`, but also 
